"use strict";(self.webpackChunkwelldone_docs=self.webpackChunkwelldone_docs||[]).push([[5141],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return d}});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=c(n),d=a,h=p["".concat(s,".").concat(d)]||p[d]||u[d]||r;return n?i.createElement(h,o(o({ref:t},m),{},{components:n})):i.createElement(h,o({ref:t},m))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<r;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},33743:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return u}});var i=n(83117),a=n(80102),r=(n(67294),n(3905)),o=["components"],l={title:"SUI Game Example",description:"Learning about how to build a game in Sui",sidebar_position:7},s="Building a Game on Sui with VRF and Dynamic NFTs",c={unversionedId:"tutorials/sui-game/index",id:"tutorials/sui-game/index",title:"SUI Game Example",description:"Learning about how to build a game in Sui",source:"@site/docs/tutorials/sui-game/index.md",sourceDirName:"tutorials/sui-game",slug:"/tutorials/sui-game/",permalink:"/ko/tutorials/sui-game/",draft:!1,editUrl:"https://github.com/welldonestudio/welldonestudio.github.io/tree/master/docs/tutorials/sui-game/index.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{title:"SUI Game Example",description:"Learning about how to build a game in Sui",sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"SUI Coin Deployment",permalink:"/ko/tutorials/sui-move-coin/"},next:{title:"Study U&I",permalink:"/ko/tutorials/sui-game/game"}},m={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Code Tutorials",id:"code-tutorials",level:2},{value:"Smart Contract: Item Struct",id:"smart-contract-item-struct",level:3},{value:"Smart Contract: Ownership",id:"smart-contract-ownership",level:3},{value:"Smart Contract: Create Item",id:"smart-contract-create-item",level:3},{value:"Smart Contract: Request Updating Item",id:"smart-contract-request-updating-item",level:3},{value:"Smart Contract: Update Item",id:"smart-contract-update-item",level:3},{value:"Deploy Smart Contract with WELLDONE Code",id:"deploy-smart-contract-with-welldone-code",level:2},{value:"New Project",id:"new-project",level:3},{value:"Source Code",id:"source-code",level:3},{value:"Requirement",id:"requirement",level:3},{value:"Compile The Source Code",id:"compile-the-source-code",level:3},{value:"Deployment",id:"deployment",level:3},{value:"Check Out Deployed Contract",id:"check-out-deployed-contract",level:3},{value:"Calling Contract Functions",id:"calling-contract-functions",level:3},{value:"Reference",id:"reference",level:2}],p={toc:u};function d(e){var t=e.components,l=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},p,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"building-a-game-on-sui-with-vrf-and-dynamic-nfts"},"Building a Game on Sui with VRF and Dynamic NFTs"),(0,r.kt)("div",null,(0,r.kt)("span",{className:"author-sm"},"July 17, 2023"),(0,r.kt)("div",{className:"author-div"},(0,r.kt)("div",{className:"author-avatars"},(0,r.kt)("a",{href:"https://github.com/sunny0529",target:"_blank"},(0,r.kt)("img",{src:"https://avatars.githubusercontent.com/u/49579003?v=4"}))),(0,r.kt)("div",null,(0,r.kt)("span",{className:"author-name"},"Hyunsun Yoo"),(0,r.kt)("br",null),(0,r.kt)("span",{className:"author-sm"},"Software Engineer, DSRV")))),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("img",{src:n(37241).Z,alt:"template-code-sui",style:{width:"90%"}}),(0,r.kt)("p",null,"Here is an educational game prototype that can be fast, scalable, and transparent with mutable, fully on-chain NFTs and verifiable random function. Sui has a lot of unique features. Sui\u2019s unique language, Move\xa0is awesome: It\u2019s safe, efficient for blockchain, and resistant to vulnerabilities such as reentrancy. But without move expertise, here's an easy way to build a game on Sui, with a web IDE that doesn't require any development setup. And let's take a look at how Sui's unique features, such as dynamic NFTs and VRF, can enhance the gaming experience."),(0,r.kt)("p",null,"\ud83c\udfae ",(0,r.kt)("a",{parentName:"p",href:"/tutorials/sui-game/game/"},(0,r.kt)("strong",{parentName:"a"},"Study U&I")),", is playable now."),(0,r.kt)("h2",{id:"code-tutorials"},"Code Tutorials"),(0,r.kt)("h3",{id:"smart-contract-item-struct"},"Smart Contract: Item Struct"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Item NFT\n    struct Item has key, store {\n        id: UID,\n        name: string::String,\n        description: string::String,\n        url: Url,\n\n        /// TODO: add custom attributes\n        itemType: u8,\n        level: u8,\n    }\n")),(0,r.kt)("h3",{id:"smart-contract-ownership"},"Smart Contract: Ownership"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    struct Ownership has key {\n        id: UID\n    }\n\n    fun init(ctx: &mut TxContext) {\n        let ownership = Ownership {\n            id: object::new(ctx),\n        };\n        \n        /// Transfer the ownership object to the module/package publisher\n        transfer::transfer(ownership, tx_context::sender(ctx));\n    }\n")),(0,r.kt)("p",null,"Use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Ownership")," object to ensure that only authorized people can mint and modify NFTs. In this example, the authorized person is the module/package publisher (the game company). Transfer the ",(0,r.kt)("inlineCode",{parentName:"p"},"Ownership")," object to the publisher in the ",(0,r.kt)("inlineCode",{parentName:"p"},"init")," function, which is executed only once when deploying the smart contract."),(0,r.kt)("h3",{id:"smart-contract-create-item"},"Smart Contract: Create Item"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Create a new Item by contract owner\n    public entry fun mint(\n        _: &Ownership,\n        name: vector<u8>,\n        description: vector<u8>,\n        url: vector<u8>,\n        itemType: u8,\n        recipient: address,\n        ctx: &mut TxContext\n    ) {\n        let sender = tx_context::sender(ctx);\n        let item = Item {\n            id: object::new(ctx),\n            name: string::utf8(name),\n            description: string::utf8(description),\n            url: url::new_unsafe_from_bytes(url),\n            itemType: itemType,\n            level: 0\n        };\n\n        event::emit(ItemMinted {\n            object_id: object::id(&item),\n            creator: sender,\n            name: item.name,\n        });\n\n        transfer::public_transfer(item, recipient);\n    }\n")),(0,r.kt)("p",null,"By taking Ownership as the parameter, only addresses that own the ",(0,r.kt)("inlineCode",{parentName:"p"},"Ownership")," object can call the ",(0,r.kt)("inlineCode",{parentName:"p"},"mint")," function."),(0,r.kt)("h3",{id:"smart-contract-request-updating-item"},"Smart Contract: Request Updating Item"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    /// An object for consign\n    struct ConsignedObj has key, store {\n        id: UID,\n        /// owner of the consigned object\n        sender: address,\n        /// the consigned object\n        item_axe: Option<ID>,\n        item_scroll: Option<ID>,\n    }\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ConsignedObj")," is an object for consigning an item to the game company to request an update on the item."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    /// `users` create a consign for consigning\n    /// an Item to `third_party`\n    public entry fun create(\n        third_party: address,\n        item_axe: Item,\n        item_scroll: Item,\n        ctx: &mut TxContext\n    ) {\n        assert!(item_axe.itemType == 0 && item_scroll.itemType != 0, EItemType);\n        assert!(item_axe.level < 255 && item_scroll.level > 0, EItemLevel);\n\n        let sender = tx_context::sender(ctx);\n        let consigned = ConsignedObj { id: object::new(ctx), item_axe: option::none(), item_scroll: option::none(), sender: sender };\n            \n        option::fill(&mut consigned.item_axe, object::id(&item_axe));\n        dynamic_object_field::add(&mut consigned.id, 0, item_axe);\n\n        option::fill(&mut consigned.item_scroll, object::id(&item_scroll));\n        dynamic_object_field::add(&mut consigned.id, 1, item_scroll);\n\n        // consign the object with the trusted third party\n        transfer::public_transfer(consigned, third_party);\n    }\n    }\n")),(0,r.kt)("p",null,"Users can call the ",(0,r.kt)("inlineCode",{parentName:"p"},"create")," function to request enchanting their item. In the second parameter, pass the Axe item want to enchant, and in the third parameter, pass the Scroll item want to spend to enchant."),(0,r.kt)("h3",{id:"smart-contract-update-item"},"Smart Contract: Update Item"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    /// Trusted third party can update nft\n    /// Update the `level` of 'Item'\n    public entry fun upgrade_level(_: &Ownership, obj: ConsignedObj, output: vector<u8>, input: vector<u8>, public_key: vector<u8>, proof: vector<u8>, ctx: &mut TxContext) {\n        let verified = ecvrf::ecvrf_verify(&output, &input, &public_key, &proof);\n        event::emit(VerifiedEvent {is_verified: verified});\n\n        assert!(!verified, ENotVerified);\n\n        let third_party = tx_context::sender(ctx);\n        let ConsignedObj {\n            id: id,\n            sender: sender,\n            item_axe: temp_a,\n            item_scroll: temp_b,\n        } = obj;\n\n        let item_axe: Item = dynamic_object_field::remove(&mut id, 0);\n        let item_axe_id = option::extract(&mut temp_a);\n        assert!(object::id(&item_axe) == item_axe_id, 0);\n\n        let item_scroll: Item = dynamic_object_field::remove(&mut id, 1);\n        let item_scroll_id = option::extract(&mut temp_b);\n        assert!(object::id(&item_scroll) == item_scroll_id, 0);\n\n        assert!(item_axe.itemType == 0 && item_scroll.itemType != 0, EItemType);\n        assert!(item_axe.level < 255 && item_scroll.level > 0, EItemLevel);\n\n        let popedOutput = vector::pop_back(&mut output);\n        let bonus: u8 = if (popedOutput > 128) { 1 } else { 0 };\n\n        item_axe.level = item_axe.level + item_scroll.level + bonus;\n        \n        event::emit(ItemUpgrade {\n            object_id: item_axe_id,\n            creator: third_party,\n            name: item_axe.name,\n            level: item_axe.level,\n        });\n\n        object::delete(id);\n        transfer::public_transfer(item_axe, sender);\n        burn(item_scroll, ctx);\n    }\n")),(0,r.kt)("p",null,"The module/package publisher (the game company) can enchant an item. There are three main parts to enchanting:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Verifiable Random Function (",(0,r.kt)("a",{parentName:"li",href:"https://docs.sui.io/learn/cryptography/ecvrf"},"VRF"),")")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"enchant")," function takes parameters a random ",(0,r.kt)("inlineCode",{parentName:"li"},"output"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"alpha_string"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"public_key"),", and ",(0,r.kt)("inlineCode",{parentName:"li"},"proof")," generated by the game company via VRF. Then inside the function, the random output is verified, and if it passes, the result of random output determines whether or not to grant bonus levels when enchanting items.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Why is the Verifiable Random Function important in games?"),(0,r.kt)("div",null,(0,r.kt)("div",null," A Verifiable Random Function (VRF) enables the holder of a private key to generate a hashed value for the message, which can be verified by anyone possessing the corresponding public key to ensure the validity of the hash. Therefore, by using VRF users have the ability to verify the random value used in games. Moreover, it also allows users can provide an input seed for the game company to use when generating a random value, and users can always verify that the game company used that seed to generate the random. Since the Random Function is such an important component of gaming and blockchain, it's important to provide transparent random for Sui users."))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"For example, the game company will generate the random output using information about the user as an input seed. Then the user can always verify that the game company generated the random value with information about them.")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Dynamic NFTs")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Once the random output determines how much the item will level up, change the properties of the NFT. All game items such as weapons and armor are all Dynamic NFTs on-chain. As users enchant their item with scroll, attributes such as level, power, and delay are all updated live and can be checked through Sui Explorer.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Why is the Dynamic NFTs important in games?"),(0,r.kt)("div",null,(0,r.kt)("div",null," Traditional NFTs are immutable once minted, while Dynamic NFTs are programmed to change their value based on external inputs. Using Dynamic NFTs in the game enables a program to change the properties of a user's items to become more powerful based on the user's contributions as they progress through the game. Sui's fast speed allows for real-time changes of NFT in fast-paced games. Additionally, Sui's comprehensive support for fully on-chain NFTs enables dynamic NFTs, which offer great advantages in gaming applications."))),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Returning NFT to the user who requested the enchanting")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Using the ",(0,r.kt)("inlineCode",{parentName:"li"},"ConsignedObj"),", return NFT to the user who requested the enchanting.")),(0,r.kt)("h2",{id:"deploy-smart-contract-with-welldone-code"},"Deploy Smart Contract with WELLDONE Code"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Please refer to ",(0,r.kt)("a",{parentName:"p",href:"https://docs.welldonestudio.io/code/getting-started"},"here")," to get started.")),(0,r.kt)("h3",{id:"new-project"},"New Project"),(0,r.kt)("p",null,"Automatically generate a contract structure. Click the ",(0,r.kt)("inlineCode",{parentName:"p"},"Create")," button to create a contract structure."),(0,r.kt)("img",{src:n(29647).Z,alt:"template-code-sui",style:{width:"50%"}}),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"You can create your own contract projects without using the features above. However, for the remix plugin to build and deploy the contract, it must be built within the directory ",(0,r.kt)("inlineCode",{parentName:"p"},"sui/"),". If you start a new project, the structure should look like the following.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"sui\n\u2514\u2500\u2500 item\n    \u251c\u2500\u2500 Move.toml\n    \u251c\u2500\u2500 Move.lock\n    \u2514\u2500\u2500 sources\n        \u2514\u2500\u2500 item.move\n")),(0,r.kt)("h3",{id:"source-code"},"Source Code"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="item.move"',title:'"item.move"'},'module examples::item {\n    use sui::url::{Self, Url};\n    use std::string;\n    use sui::object::{Self, ID, UID};\n    use sui::event;\n    use sui::transfer;\n    use sui::tx_context::{Self, TxContext};\n    use std::option::{Self, Option};\n    use sui::dynamic_object_field;\n    use sui::ecvrf;\n    use std::vector;\n\n    /// Item NFT\n    struct Item has key, store {\n        id: UID,\n        name: string::String,\n        description: string::String,\n        url: Url,\n\n        /// TODO: add custom attributes\n        itemType: u8,\n        level: u8,\n    }\n\n    struct Ownership has key {\n        id: UID\n    }\n\n    /// An object for consign\n    struct ConsignedObj has key, store {\n        id: UID,\n        /// owner of the consigned object\n        sender: address,\n        /// the consigned object\n        item_axe: Option<ID>,\n        item_scroll: Option<ID>,\n    }\n\n    fun init(ctx: &mut TxContext) {\n        let ownership = Ownership {\n            id: object::new(ctx),\n        };\n        \n        /// Transfer the ownership object to the module/package publisher\n        transfer::transfer(ownership, tx_context::sender(ctx));\n    }\n\n    // ===== Error codes =====\n\n    const ENotVerified: u64 = 0;\n    const EItemType: u64 = 1;\n    const EItemLevel: u64 = 2;\n\n    // ===== Events =====\n\n    struct ItemMinted has copy, drop {\n        // The Object ID of the Item\n        object_id: ID,\n        // The creator of the Item\n        creator: address,\n        // The name of the Item\n        name: string::String,\n    }\n    \n    struct ItemUpgrade has copy, drop {\n        // The Object ID of the Item\n        object_id: ID,\n        // The creator of the Item\n        creator: address,\n        // The name of the Item\n        name: string::String,\n\n        level: u8,\n    }\n\n    /// Event on whether the output is verified\n    struct VerifiedEvent has copy, drop {\n        is_verified: bool,\n    }\n\n    // ===== Public view functions =====\n    \n    /// Get the Item\'s `name`\n    public fun name(item: &Item): &string::String {\n        &item.name\n    }\n\n    /// Get the Item\'s `description`\n    public fun description(item: &Item): &string::String {\n        &item.description\n    }\n\n    /// Get the Item\'s `url`\n    public fun url(item: &Item): &Url {\n        &item.url\n    }\n\n    /// Get the Item\'s `itemType`\n    public fun item_typel(item: &Item): &u8 {\n        &item.itemType\n    }\n\n    /// Get the Item\'s `level`\n    public fun level(item: &Item): &u8 {\n        &item.level\n    }\n\n    // ===== Entrypoints =====\n\n    /// Create a new Item\n    fun mint_internal(\n        name: vector<u8>,\n        description: vector<u8>,\n        url: vector<u8>,\n        itemType: u8,\n        level: u8,\n        ctx: &mut TxContext,\n    ) {\n        let item = Item {\n            id: object::new(ctx),\n            name:  string::utf8(name),\n            description:  string::utf8(description),\n            url: url::new_unsafe_from_bytes(url),\n            itemType: itemType,\n            level: level,\n        };\n\n        event::emit(ItemMinted {\n            object_id: object::id(&item),\n            creator: tx_context::sender(ctx),\n            name: item.name,\n        });\n\n        transfer::public_transfer(item, tx_context::sender(ctx));\n    }\n\n    public entry fun buy(\n        itemType: u8,\n        ctx: &mut TxContext\n    ) {\n        if (itemType == 0) {\n            let name = b"axe";\n            let desc = b"axe";\n            let url = b"https://";\n            mint_internal(name, desc, url, itemType, 0, ctx);\n        };\n        if (itemType == 1) {\n            let name = b"scroll 1";\n            let desc = b"scroll 1";\n            let url = b"https://";\n            mint_internal(name, desc, url, itemType, 3, ctx);\n        };\n        if (itemType == 2) {\n            let name = b"scroll 2";\n            let desc = b"scroll 2";\n            let url = b"https://";\n            mint_internal(name, desc, url, itemType, 6, ctx);\n        };\n        if (itemType == 3) {\n            let name = b"scroll 3";\n            let desc = b"scroll 3";\n            let url = b"https://";\n            mint_internal(name, desc, url, itemType, 9, ctx);\n        };\n    }\n\n    /// Create a new Item by contract owner\n    public entry fun mint(\n        _: &Ownership,\n        name: vector<u8>,\n        description: vector<u8>,\n        url: vector<u8>,\n        itemType: u8,\n        recipient: address,\n        ctx: &mut TxContext\n    ) {\n        let sender = tx_context::sender(ctx);\n        let item = Item {\n            id: object::new(ctx),\n            name: string::utf8(name),\n            description: string::utf8(description),\n            url: url::new_unsafe_from_bytes(url),\n            itemType: itemType,\n            level: 0\n        };\n\n        event::emit(ItemMinted {\n            object_id: object::id(&item),\n            creator: sender,\n            name: item.name,\n        });\n\n        transfer::public_transfer(item, recipient);\n    }\n\n    /// Transfer `Item` to `recipient`\n    public entry fun transfer(\n        item: Item, recipient: address, _: &mut TxContext\n    ) {\n        transfer::public_transfer(item, recipient)\n    }\n\n    /// `users` create a consign for consigning\n    /// an Item to `third_party`\n    public entry fun create(\n        third_party: address,\n        item_axe: Item,\n        item_scroll: Item,\n        ctx: &mut TxContext\n    ) {\n        assert!(item_axe.itemType == 0 && item_scroll.itemType != 0, EItemType);\n        assert!(item_axe.level < 255 && item_scroll.level > 0, EItemLevel);\n\n        let sender = tx_context::sender(ctx);\n        let consigned = ConsignedObj { id: object::new(ctx), item_axe: option::none(), item_scroll: option::none(), sender: sender };\n            \n        option::fill(&mut consigned.item_axe, object::id(&item_axe));\n        dynamic_object_field::add(&mut consigned.id, 0, item_axe);\n\n        option::fill(&mut consigned.item_scroll, object::id(&item_scroll));\n        dynamic_object_field::add(&mut consigned.id, 1, item_scroll);\n\n        // consign the object with the trusted third party\n        transfer::public_transfer(consigned, third_party);\n    }\n\n    /// Trusted third party can update nft\n    /// Update the `level` of \'Item\'\n    public entry fun upgrade_level(_: &Ownership, obj: ConsignedObj, output: vector<u8>, input: vector<u8>, public_key: vector<u8>, proof: vector<u8>, ctx: &mut TxContext) {\n        let verified = ecvrf::ecvrf_verify(&output, &input, &public_key, &proof);\n        event::emit(VerifiedEvent {is_verified: verified});\n\n        assert!(!verified, ENotVerified);\n\n        let third_party = tx_context::sender(ctx);\n        let ConsignedObj {\n            id: id,\n            sender: sender,\n            item_axe: temp_a,\n            item_scroll: temp_b,\n        } = obj;\n\n        let item_axe: Item = dynamic_object_field::remove(&mut id, 0);\n        let item_axe_id = option::extract(&mut temp_a);\n        assert!(object::id(&item_axe) == item_axe_id, 0);\n\n        let item_scroll: Item = dynamic_object_field::remove(&mut id, 1);\n        let item_scroll_id = option::extract(&mut temp_b);\n        assert!(object::id(&item_scroll) == item_scroll_id, 0);\n\n        assert!(item_axe.itemType == 0 && item_scroll.itemType != 0, EItemType);\n        assert!(item_axe.level < 255 && item_scroll.level > 0, EItemLevel);\n\n        let popedOutput = vector::pop_back(&mut output);\n        let bonus: u8 = if (popedOutput > 128) { 1 } else { 0 };\n\n        item_axe.level = item_axe.level + item_scroll.level + bonus;\n        \n        event::emit(ItemUpgrade {\n            object_id: item_axe_id,\n            creator: third_party,\n            name: item_axe.name,\n            level: item_axe.level,\n        });\n\n        object::delete(id);\n        transfer::public_transfer(item_axe, sender);\n        burn(item_scroll, ctx);\n    }\n\n    /// Permanently delete `Item`\n    public entry fun burn(item: Item, _: &mut TxContext) {\n        let Item { id, name: _, description: _, url: _, itemType: _, level : _, } = item;\n        object::delete(id)\n    }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="Move.toml"',title:'"Move.toml"'},'[package]\nname = "Examples"\nversion = "0.0.1"\n\n[dependencies]\nSui = { git = "https://github.com/MystenLabs/sui.git", subdir="crates/sui-framework/packages/sui-framework/", rev = "testnet" }\n\n[addresses]\nexamples = "0x0"\n')),(0,r.kt)("h3",{id:"requirement"},"Requirement"),(0,r.kt)("p",null,"In this scenario, you need two accounts. An account that acts as ",(0,r.kt)("inlineCode",{parentName:"p"},"the game company")," that will deploy the Smart Contract, and an account that acts as ",(0,r.kt)("inlineCode",{parentName:"p"},"the game user"),"."),(0,r.kt)("h3",{id:"compile-the-source-code"},"Compile The Source Code"),(0,r.kt)("p",null,"Connect to the WELLDONE Code with ",(0,r.kt)("inlineCode",{parentName:"p"},"a game company")," account, and select the project you want to compile. For now, let's choose ",(0,r.kt)("inlineCode",{parentName:"p"},"sui/item")," and click ",(0,r.kt)("inlineCode",{parentName:"p"},"Compile")," button."),(0,r.kt)("img",{src:n(24788).Z,alt:"02_project-to-compile-item",style:{width:"480px"}}),(0,r.kt)("h3",{id:"deployment"},"Deployment"),(0,r.kt)("p",null,"If the compilation succeed, you can see mv file ",(0,r.kt)("inlineCode",{parentName:"p"},"item.mv"),"."),(0,r.kt)("p",null,"Click the ",(0,r.kt)("inlineCode",{parentName:"p"},"Deploy")," button."),(0,r.kt)("img",{src:n(60726).Z,alt:"03_build-file-item",style:{width:"480px"}}),(0,r.kt)("p",null,"and you can see wallet popup. Let's click ",(0,r.kt)("inlineCode",{parentName:"p"},"Send")," button."),(0,r.kt)("img",{src:n(95716).Z,alt:"04_sui-wallet-popup",style:{width:"480px"}}),(0,r.kt)("h3",{id:"check-out-deployed-contract"},"Check Out Deployed Contract"),(0,r.kt)("p",null,"After deployment, you can see Item module and functions."),(0,r.kt)("h3",{id:"calling-contract-functions"},"Calling Contract Functions"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Change to ",(0,r.kt)("inlineCode",{parentName:"p"},"a game user")," account, and Select ",(0,r.kt)("inlineCode",{parentName:"p"},"buy")," function. Input 0 to buy an axe, and click ",(0,r.kt)("inlineCode",{parentName:"p"},"buy")," button. And input 1 to buy a scroll, and click ",(0,r.kt)("inlineCode",{parentName:"p"},"buy")," button.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"After sending each transaction, look up the received Tx Hash in ",(0,r.kt)("a",{parentName:"p",href:"https://suiexplorer.com/"},"SUI Explorer")," to check the object ID of the item that you bought for the next step.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Run the ",(0,r.kt)("inlineCode",{parentName:"p"},"create")," function. The first parameter is ",(0,r.kt)("inlineCode",{parentName:"p"},"the game company")," address that deployed this Smart Contract. The second parameter is an object Id of the item that you bought, The value you checked in step 2. The third parameter is the same, but one of these parameters must be axe, and scroll, respectively.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"After sending the create transaction, look up the received Tx Hash in ",(0,r.kt)("a",{parentName:"p",href:"https://suiexplorer.com/"},"SUI Explorer")," to check the object ID of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ConsignedObj")," for the next step.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Return to ",(0,r.kt)("inlineCode",{parentName:"p"},"the game company")," account and run the ",(0,r.kt)("inlineCode",{parentName:"p"},"upgrade_level")," function. The first parameter is the object ID of ",(0,r.kt)("inlineCode",{parentName:"p"},"Ownership"),". And the second parameter is the object ID of ",(0,r.kt)("inlineCode",{parentName:"p"},"ConsignedObj")," that you checked in Step 4. The third through sixth parameters are associated with the VRF.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"After enchant transaction, check if Item was returned to ",(0,r.kt)("inlineCode",{parentName:"p"},"the game user")," and updated in ",(0,r.kt)("a",{parentName:"p",href:"https://suiexplorer.com/"},"SUI Explorer"),"."))),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"reference"},"Reference"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://examples.sui.io/samples/nft.html"},"https://examples.sui.io/samples/nft.html")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://docs.sui.io/learn/cryptography/ecvrf"},"https://docs.sui.io/learn/cryptography/ecvrf")))}d.isMDXComponent=!0},24788:function(e,t,n){t.Z=n.p+"assets/images/02-8adc714ced13f6a7dba6abb909f9ee4e.png"},60726:function(e,t,n){t.Z=n.p+"assets/images/03-4f55a40dac9e2fcd5633644fd358e141.png"},95716:function(e,t,n){t.Z=n.p+"assets/images/04-cc7599d0839c3d94ecbf80ec1340876f.png"},29647:function(e,t,n){t.Z=n.p+"assets/images/new-project-sui-d601ee9d8bfcaf072ca1f96eb7d793a1.png"},37241:function(e,t,n){t.Z=n.p+"assets/images/study-u-and-i-4d9e832a1b28300e0be506fa2d8fbce1.png"}}]);