"use strict";(self.webpackChunkwelldone_docs=self.webpackChunkwelldone_docs||[]).push([[9975],{3905:function(n,e,t){t.d(e,{Zo:function(){return l},kt:function(){return m}});var r=t(67294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function s(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?s(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function i(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},s=Object.keys(n);for(r=0;r<s.length;r++)t=s[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);for(r=0;r<s.length;r++)t=s[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var c=r.createContext({}),u=function(n){var e=r.useContext(c),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},l=function(n){var e=u(n.components);return r.createElement(c.Provider,{value:e},n.children)},d={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},p=r.forwardRef((function(n,e){var t=n.components,a=n.mdxType,s=n.originalType,c=n.parentName,l=i(n,["components","mdxType","originalType","parentName"]),p=u(t),m=a,h=p["".concat(c,".").concat(m)]||p[m]||d[m]||s;return t?r.createElement(h,o(o({ref:e},l),{},{components:t})):r.createElement(h,o({ref:e},l))}));function m(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var s=t.length,o=new Array(s);o[0]=p;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=n,i.mdxType="string"==typeof n?n:a,o[1]=i;for(var u=2;u<s;u++)o[u]=t[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},47811:function(n,e,t){t.r(e),t.d(e,{assets:function(){return l},contentTitle:function(){return c},default:function(){return m},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return d}});var r=t(83117),a=t(80102),s=(t(67294),t(3905)),o=["components"],i={keywords:["Sui sendTransaction","dapp:signAndSendTransaction","Sui"],description:"Sending Transactions in Sui"},c="Sui",u={unversionedId:"wallet/developer-guide/sending-transaction/sui",id:"wallet/developer-guide/sending-transaction/sui",title:"Sui",description:"Sending Transactions in Sui",source:"@site/docs/wallet/developer-guide/sending-transaction/sui.md",sourceDirName:"wallet/developer-guide/sending-transaction",slug:"/wallet/developer-guide/sending-transaction/sui",permalink:"/wallet/developer-guide/sending-transaction/sui",draft:!1,editUrl:"https://github.com/welldonestudio/welldonestudio.github.io/tree/master/docs/wallet/developer-guide/sending-transaction/sui.md",tags:[],version:"current",frontMatter:{keywords:["Sui sendTransaction","dapp:signAndSendTransaction","Sui"],description:"Sending Transactions in Sui"},sidebar:"tutorialSidebar",previous:{title:"Solana",permalink:"/wallet/developer-guide/sending-transaction/solana"},next:{title:"Execute the Contract",permalink:"/execute-the-contract"}},l={},d=[{value:"1. Returns",id:"1-returns",level:2},{value:"2. Params",id:"2-params",level:2},{value:"3. Example",id:"3-example",level:2}],p={toc:d};function m(n){var e=n.components,t=(0,a.Z)(n,o);return(0,s.kt)("wrapper",(0,r.Z)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"sui"},"Sui"),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"The following is an explanation of how to initiate a transfer transaction in Sui network by invoking the through ",(0,s.kt)("inlineCode",{parentName:"p"},"dapp.request"),". We recommend utilizing a dedicated library rather than accessing the service directly if you want a greater degree of abstraction than the official API provides.")),(0,s.kt)("p",null,"To send a transaction in Sui network, it needs to be followed the steps below."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Detecting of Universal Provider (",(0,s.kt)("inlineCode",{parentName:"li"},"window.dapp"),")"),(0,s.kt)("li",{parentName:"ol"},"Detecting the Sui network to which the user is linked"),(0,s.kt)("li",{parentName:"ol"},"Import the Sui account of the user")),(0,s.kt)("p",null,"The WELLDONE Wallet finds and imports networks associated with that wallet address. Before submitting a transaction, you should evaluate whether to transmit it to the mainnet or the testnet. The following format can be used to transmit the transaction:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const response = await dapp.request('sui', {\n  method: 'dapp:signAndSendTransaction',\n  params: [HEX_STRING_TX_DATA],\n});\n")),(0,s.kt)("h2",{id:"1-returns"},"1. Returns"),(0,s.kt)("p",null,"This method returns the transaction hash value as a ",(0,s.kt)("inlineCode",{parentName:"p"},"Promise")," object of type string because you can send multiple transactions as well as one transaction."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"Promise<string[]>;\n")),(0,s.kt)("h2",{id:"2-params"},"2. Params"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"type HEX_STRING_TX_DATA = string;\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"HEX_STRING_TX_DATA")," must be passed to the parameter in order for a transaction to be sent from Sui. The ",(0,s.kt)("inlineCode",{parentName:"li"},"@mysten/sui.js")," library can provide these values, and the ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/MystenLabs/sui"},"link")," and the example below can explain their detailed usage.")),(0,s.kt)("h2",{id:"3-example"},"3. Example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-javascript"},"import { TransactionBlock } from '@mysten/sui.js';\nconst CHAIN_NAME = 'sui';\nconst SUI_RPC_URL = 'https://wallet-rpc.devnet.sui.io/';\n\nconst request = async (method, params) => {\n  const res = await fetch(SUI_RPC_URL, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      id: 0,\n      jsonrpc: '2.0',\n      method,\n      params: params || [],\n    }),\n  });\n\n  const { result } = await res.json();\n  return result;\n};\n\nconst getSerializedTransaction = async (accounts) => {\n  try {\n    /*\n      This is an example of a sui provider\n      Production development should use JsonRpcProvider from @mysten/sui.js\n      https://github.com/MystenLabs/sui/tree/main/sdk/typescript#writing-apis\n    */\n    const suiProvider = {\n      provider: {\n        getReferenceGasPrice: async () => {\n          const result = await request('suix_getReferenceGasPrice', []);\n          return result;\n        },\n        getCoins: async ({ owner, coinType }) => {\n          const result = await request('suix_getCoins', [owner, coinType]);\n          return result;\n        },\n        multiGetObjects: async ({ ids, options }) => {\n          const result = await request('sui_multiGetObjects', [ids, options]);\n          return result;\n        },\n        dryRunTransactionBlock: async ({ transactionBlock }) => {\n          const result = await request('sui_dryRunTransactionBlock', [\n            typeof transactionBlock === 'string'\n              ? transactionBlock\n              : Buffer.from(transactionBlock).toString('base64'),\n          ]);\n          return result;\n        },\n      },\n    };\n\n    const coins = await request('suix_getCoins', [accounts.address]);\n\n    const coinType = '0x2::sui::SUI';\n    const filtered = coins.data.filter((item) => item.coinType === coinType);\n\n    const txb = new TransactionBlock();\n    txb.setSender(accounts.address);\n\n    txb.setGasPayment(\n      filtered.map((item) => {\n        return {\n          objectId: item.coinObjectId,\n          version: item.version,\n          digest: item.digest,\n        };\n      }),\n    );\n    const [coin] = txb.splitCoins(txb.gas, [txb.pure(10000000)]);\n\n    txb.transferObjects([coin], txb.pure(accounts.address));\n    const transactionBlock = await txb.build(suiProvider);\n    return `0x${Buffer.from(transactionBlock).toString('hex')}`;\n  } catch (error) {\n    alert(error.message);\n  }\n};\n\nasync function sendTransaction() {\n  try {\n    const HEX_STRING_TX_DATA = await getSerializedTransaction();\n    const response = await dapp.request(CHAIN_NAME, {\n      method: 'dapp:signAndSendTransaction',\n      params: [`${HEX_STRING_TX_DATA}`],\n    });\n    const txHash = response[0];\n\n    setTxHash(txHash);\n  } catch (error) {\n    alert(`Error Message: ${error.message}\\nError Code: ${error.code}`);\n  }\n}\n\nconst sendTransaction = async () => {\n  // get accounts first\n  const accounts = await dapp.request(CHAIN_NAME, { method: 'dapp:accounts' });\n  const HEX_STRING_TX_DATA = await getSerializedTransaction(accounts[CHAIN_NAME]);\n  // sending a transaction\n  try {\n    const response = await dapp.request(CHAIN_NAME, {\n      method: 'dapp:signAndSendTransaction',\n      params: [\n        // use serialized transaction\n        [`${HEX_STRING_TX_DATA}`],\n      ],\n    });\n    const txHash = response[0];\n  } catch (error) {\n    /*\n        {\n          message: 'User denied transaction signature',\n          code: 4001,\n        }\n      */\n  }\n};\n")),(0,s.kt)("p",null,"To complete the transaction, follow the steps outlined below. A faucet is required to transmit a transaction. You can request faucet through the FAUCET tab in the wallet."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function sendTransaction() {\n  const CHAIN_NAME = 'sui';\n  const SUI_RPC_URL = 'https://wallet-rpc.devnet.sui.io/';\n  const [accounts, setAccounts] = React.useState(null);\n  const [txHash, setTxHash] = React.useState(null);\n\n  const request = async (method, params) => {\n    const res = await fetch(SUI_RPC_URL, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        id: 0,\n        jsonrpc: '2.0',\n        method,\n        params: params || [],\n      }),\n    });\n\n    const { result } = await res.json();\n    return result;\n  };\n\n  /*\n    This is an example of a sui provider\n    Production development should use JsonRpcProvider from @mysten/sui.js\n    https://github.com/MystenLabs/sui/tree/main/sdk/typescript#writing-apis\n  */\n  const suiProvider = {\n    provider: {\n      getReferenceGasPrice: async () => {\n        const result = await request('suix_getReferenceGasPrice', []);\n        return result;\n      },\n      getCoins: async ({ owner, coinType }) => {\n        const result = await request('suix_getCoins', [owner, coinType]);\n        return result;\n      },\n      multiGetObjects: async ({ ids, options }) => {\n        const result = await request('sui_multiGetObjects', [ids, options]);\n        return result;\n      },\n      dryRunTransactionBlock: async ({ transactionBlock }) => {\n        const result = await request('sui_dryRunTransactionBlock', [\n          typeof transactionBlock === 'string'\n            ? transactionBlock\n            : Buffer.from(transactionBlock).toString('base64'),\n        ]);\n        return result;\n      },\n    },\n  };\n\n  const getSerializedTransaction = async () => {\n    try {\n      const coins = await request('suix_getCoins', [accounts.address]);\n\n      const coinType = '0x2::sui::SUI';\n      const filtered = coins.data.filter((item) => item.coinType === coinType);\n\n      const txb = new TransactionBlock();\n      txb.setSender(accounts.address);\n\n      txb.setGasPayment(\n        filtered.map((item) => {\n          return {\n            objectId: item.coinObjectId,\n            version: item.version,\n            digest: item.digest,\n          };\n        }),\n      );\n      const [coin] = txb.splitCoins(txb.gas, [txb.pure(10000000)]);\n\n      txb.transferObjects([coin], txb.pure(accounts.address));\n      const transactionBlock = await txb.build(suiProvider);\n      return `0x${Buffer.from(transactionBlock).toString('hex')}`;\n    } catch (error) {\n      alert(error.message);\n    }\n  };\n\n  async function handleGetAccount() {\n    try {\n      const accounts = await dapp.request(CHAIN_NAME, {\n        method: 'dapp:accounts',\n      });\n      if (Object.keys(accounts).length === 0) {\n        throw new Error('There is no accounts.');\n      }\n      const chainId = await window.dapp.networks.sui.chain;\n\n      if ((chainId === 'mainnet') | (chainId === 'testnet')) {\n        throw new Error('Please chagne to SUI devnet in WELLDONE Wallet');\n      }\n      setAccounts(accounts[CHAIN_NAME]);\n    } catch (error) {\n      alert(error.message);\n    }\n  }\n\n  async function handleSendTransaction() {\n    try {\n      const HEX_STRING_TX_DATA = await getSerializedTransaction();\n      const response = await dapp.request(CHAIN_NAME, {\n        method: 'dapp:signAndSendTransaction',\n        params: [`${HEX_STRING_TX_DATA}`],\n      });\n      const txHash = response[0];\n\n      setTxHash(txHash);\n    } catch (error) {\n      alert(`Error Message: ${error.message}\\nError Code: ${error.code}`);\n    }\n  }\n\n  return (\n    <>\n      {accounts ? (\n        <>\n          <Button onClick={handleSendTransaction} type=\"button\">\n            Send a Transaction\n          </Button>\n          <ResultTooltip style={{ background: '#3B48DF' }}>\n            <b>Accounts:</b> {accounts.address}\n          </ResultTooltip>\n        </>\n      ) : (\n        <>\n          <Button onClick={handleGetAccount} type=\"button\">\n            Get Account\n          </Button>\n          <div>You have to get account first!</div>\n        </>\n      )}\n      {txHash && (\n        <ResultTooltip style={{ background: '#F08080' }}>\n          <b>Transaction Hash:</b> {txHash}\n        </ResultTooltip>\n      )}\n    </>\n  );\n}\n")))}m.isMDXComponent=!0}}]);