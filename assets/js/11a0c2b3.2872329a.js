"use strict";(self.webpackChunkwelldone_docs=self.webpackChunkwelldone_docs||[]).push([[7074],{3905:function(e,r,t){t.d(r,{Zo:function(){return d},kt:function(){return m}});var n=t(67294);function o(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function i(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function a(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?i(Object(t),!0).forEach((function(r){o(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function l(e,r){if(null==e)return{};var t,n,o=function(e,r){if(null==e)return{};var t,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=n.createContext({}),p=function(e){var r=n.useContext(s),t=r;return e&&(t="function"==typeof e?e(r):a(a({},r),e)),t},d=function(e){var r=p(e.components);return n.createElement(s.Provider,{value:r},e.children)},u={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},c=n.forwardRef((function(e,r){var t=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(t),m=o,v=c["".concat(s,".").concat(m)]||c[m]||u[m]||i;return t?n.createElement(v,a(a({ref:r},d),{},{components:t})):n.createElement(v,a({ref:r},d))}));function m(e,r){var t=arguments,o=r&&r.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=c;var l={};for(var s in r)hasOwnProperty.call(r,s)&&(l[s]=r[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var p=2;p<i;p++)a[p]=t[p];return n.createElement.apply(null,a)}return n.createElement.apply(null,t)}c.displayName="MDXCreateElement"},65087:function(e,r,t){t.r(r),t.d(r,{assets:function(){return d},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return u}});var n=t(83117),o=t(80102),i=(t(67294),t(3905)),a=["components"],l={keywords:["Universal Provider","How does Universal Provider wrap for multi-chain developers?"],description:"How Universal Provider supports multi-chain developers",sidebar_position:1},s="About Universal Provider",p={unversionedId:"wallet/developer-guide/provider-api/how-we-wrap-for-multichain",id:"wallet/developer-guide/provider-api/how-we-wrap-for-multichain",title:"About Universal Provider",description:"How Universal Provider supports multi-chain developers",source:"@site/docs/wallet/developer-guide/provider-api/how-we-wrap-for-multichain.md",sourceDirName:"wallet/developer-guide/provider-api",slug:"/wallet/developer-guide/provider-api/how-we-wrap-for-multichain",permalink:"/wallet/developer-guide/provider-api/how-we-wrap-for-multichain",draft:!1,editUrl:"https://github.com/welldonestudio/welldonestudio.github.io/tree/master/docs/wallet/developer-guide/provider-api/how-we-wrap-for-multichain.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{keywords:["Universal Provider","How does Universal Provider wrap for multi-chain developers?"],description:"How Universal Provider supports multi-chain developers",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Provider API",permalink:"/provider-api"},next:{title:"Methods",permalink:"/wallet/developer-guide/provider-api/method"}},d={},u=[{value:"How does the Universal Provider wrap for multi-chain developers?",id:"how-does-the-universal-provider-wrap-for-multi-chain-developers",level:2}],c={toc:u};function m(e){var r=e.components,t=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,n.Z)({},c,t,{components:r,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"about-universal-provider"},"About Universal Provider"),(0,i.kt)("h2",{id:"how-does-the-universal-provider-wrap-for-multi-chain-developers"},"How does the Universal Provider wrap for multi-chain developers?"),(0,i.kt)("p",null,"Since ",(0,i.kt)("strong",{parentName:"p"},"Universal Provider")," supports multi-chain environments, Web3 developers may simply manage their development environments by utilizing WELLDONE Wallet, without having to install and maintain numerous libraries. The provider injects libraries supported by each blockchain network, such as Ethereum's ",(0,i.kt)("inlineCode",{parentName:"p"},"ethers.js"),", NEAR's ",(0,i.kt)("inlineCode",{parentName:"p"},"near-api-js"),", Cosmos' ",(0,i.kt)("inlineCode",{parentName:"p"},"cosmjs"),", Solana's ",(0,i.kt)("inlineCode",{parentName:"p"},"web3.js"),", Celo's ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractKit"),", Polkadot's ",(0,i.kt)("inlineCode",{parentName:"p"},"util-crypto"),", and others."),(0,i.kt)("p",null,"Since it is directly linked to the developer-friendly WELLDONE Wallet, ",(0,i.kt)("strong",{parentName:"p"},"Universal Provider")," offers middleware that captures and processes multiple requests from a plethora of networks sent from the frontend of the wallet. For example, if you would like to execute a transaction to Neon network, for example, you merely need to utilize the ",(0,i.kt)("inlineCode",{parentName:"p"},"dapp:sendTransaction")," method. The method helps your request to be routed to WELLDONE Wallet that wraps the libraries from a plethora of blockchain networks. Universal Provider covers and generalizes all network-related methods in this way, eliminating the need to manage each separate library. Just designate the network that you wish to query or request with a single ",(0,i.kt)("inlineCode",{parentName:"p"},"dapp")," command."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const DAPP_SEND_TRANSACTION_METHOD = 'dapp:sendTransaction';\n\nasync function handleGetAccount() {\n  try {\n    const accounts = await dapp.request(CHAIN_NAME, {\n      method: DAPP_SEND_TRANSACTION_METHOD,\n    });\n    setAccounts(accounts[CHAIN_NAME].address);\n  } catch (error) {\n    alert(error.message);\n  }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Universal Provider")," also supports the default API method that is already frequently utilized in web3 developer world. When developing your own multi-chain dApps, you do not need to worry about maintaining a slew of development dependencies since you only need to inject the ",(0,i.kt)("inlineCode",{parentName:"p"},"Universal Provider")," to support a plethora of networks. For example, you may use the existing ",(0,i.kt)("inlineCode",{parentName:"p"},"eth_accounts")," methods to query all addresses from the Ethereum blockchain. Simply browse the official document, choose the API method, and apply it to the ",(0,i.kt)("strong",{parentName:"p"},"Universal Provider"),". These solutions are straightforward, making web3 development easy."))}m.isMDXComponent=!0}}]);