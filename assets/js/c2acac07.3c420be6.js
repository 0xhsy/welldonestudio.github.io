"use strict";(self.webpackChunkwelldone_docs=self.webpackChunkwelldone_docs||[]).push([[1578],{3905:function(n,e,t){t.d(e,{Zo:function(){return m},kt:function(){return d}});var s=t(67294);function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);e&&(s=s.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,s)}return t}function r(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){o(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function i(n,e){if(null==n)return{};var t,s,o=function(n,e){if(null==n)return{};var t,s,o={},a=Object.keys(n);for(s=0;s<a.length;s++)t=a[s],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(s=0;s<a.length;s++)t=a[s],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var c=s.createContext({}),u=function(n){var e=s.useContext(c),t=e;return n&&(t="function"==typeof n?n(e):r(r({},e),n)),t},m=function(n){var e=u(n.components);return s.createElement(c.Provider,{value:e},n.children)},l={inlineCode:"code",wrapper:function(n){var e=n.children;return s.createElement(s.Fragment,{},e)}},g=s.forwardRef((function(n,e){var t=n.components,o=n.mdxType,a=n.originalType,c=n.parentName,m=i(n,["components","mdxType","originalType","parentName"]),g=u(t),d=o,p=g["".concat(c,".").concat(d)]||g[d]||l[d]||a;return t?s.createElement(p,r(r({ref:e},m),{},{components:t})):s.createElement(p,r({ref:e},m))}));function d(n,e){var t=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var a=t.length,r=new Array(a);r[0]=g;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=n,i.mdxType="string"==typeof n?n:o,r[1]=i;for(var u=2;u<a;u++)r[u]=t[u];return s.createElement.apply(null,r)}return s.createElement.apply(null,t)}g.displayName="MDXCreateElement"},81377:function(n,e,t){t.r(e),t.d(e,{assets:function(){return m},contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return l}});var s=t(83117),o=t(80102),a=(t(67294),t(3905)),r=["components"],i={keywords:["cosmos sendTransaction","dapp:sendTransaction","cosmos","kms","@dsrv/kms"],description:"Sending Transactions using @dsrv/kms in cosmos"},c="Cosmos",u={unversionedId:"tutorials/kms/cosmos",id:"tutorials/kms/cosmos",title:"Cosmos",description:"Sending Transactions using @dsrv/kms in cosmos",source:"@site/docs/tutorials/kms/cosmos.md",sourceDirName:"tutorials/kms",slug:"/tutorials/kms/cosmos",permalink:"/tutorials/kms/cosmos",draft:!1,editUrl:"https://github.com/welldonestudio/welldonestudio.github.io/tree/master/docs/tutorials/kms/cosmos.md",tags:[],version:"current",frontMatter:{keywords:["cosmos sendTransaction","dapp:sendTransaction","cosmos","kms","@dsrv/kms"],description:"Sending Transactions using @dsrv/kms in cosmos"},sidebar:"tutorialSidebar",previous:{title:"Celo",permalink:"/tutorials/kms/celo"},next:{title:"Ethereum",permalink:"/tutorials/kms/ethereum"}},m={},l=[{value:"Create Signed transaction",id:"create-signed-transaction",level:2},{value:"1. getCosmosTx",id:"1-getcosmostx",level:3},{value:"2. getCosmosSignature",id:"2-getcosmossignature",level:3},{value:"3. createCosmosSignedTx",id:"3-createcosmossignedtx",level:3},{value:"Send Signed transaction",id:"send-signed-transaction",level:2},{value:"Examples",id:"examples",level:2}],g={toc:l};function d(n){var e=n.components,t=(0,o.Z)(n,r);return(0,a.kt)("wrapper",(0,s.Z)({},g,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"cosmos"},"Cosmos"),(0,a.kt)("admonition",{title:"Prerequisites",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"The Cosmos part carries out the practice using ",(0,a.kt)("a",{parentName:"p",href:"https://cosmos.github.io/cosmjs/"},"@cosmjs"),". Please prepare by installing the package.")),(0,a.kt)("h2",{id:"create-signed-transaction"},"Create Signed transaction"),(0,a.kt)("p",null,"For a signed transaction, there are three essential steps."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Create a raw transaction first."),(0,a.kt)("li",{parentName:"ol"},"Make a raw transaction signature."),(0,a.kt)("li",{parentName:"ol"},"Convert a raw transaction into a signed transaction by adding a signature.")),(0,a.kt)("h3",{id:"1-getcosmostx"},"1. getCosmosTx"),(0,a.kt)("p",null,"Transaction and signature are needed. We first develop a ",(0,a.kt)("inlineCode",{parentName:"p"},"getCosmosTx")," function to generate raw transaction because it is necessary to have a raw transaction to receive a signature via kms."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="getCosmosTx.ts"',title:'"getCosmosTx.ts"'},"import { Account, CHAIN } from '@dsrv/kms/lib/types';\nimport { Cosmos } from '@dsrv/kms/lib/blockchains/cosmos';\nimport {\n  Registry,\n  makeAuthInfoBytes,\n  makeSignDoc,\n  encodePubkey,\n  makeSignBytes,\n  DirectSecp256k1HdWallet,\n  TxBodyEncodeObject,\n} from '@cosmjs/proto-signing';\nimport { encodeSecp256k1Pubkey } from '@cosmjs/amino';\nimport { StargateClient, defaultRegistryTypes } from '@cosmjs/stargate';\nimport { Int53 } from '@cosmjs/math';\nimport { SignDoc } from 'cosmjs-types/cosmos/tx/v1beta1/tx';\n\ninterface RawTransaction {\n  unSignedTx: SignDoc;\n  serializedTx: string;\n}\n\nconst getTxBodyBytes = (transaction) => {\n  const registry = new Registry(defaultRegistryTypes);\n\n  const txBodyEncodeObjectTxBodyEncodeObject = {\n    typeUrl: '/cosmos.tx.v1beta1.TxBody',\n    value: {\n      messages: transaction.msgs,\n      memo: transaction.memo,\n    },\n  };\n\n  const txBodyBytes = registry.encode(txBodyEncodeObject);\n  return txBodyBytes;\n};\n\nconst getAuthInfoBytes = (transaction, pubkey) => {\n  const gasLimit = Int53.fromString(transaction.fee.gas).toNumber();\n  const authInfoBytes = makeAuthInfoBytes(\n    [\n      {\n        pubkey: encodePubkey(encodeSecp256k1Pubkey(pubkey)),\n        sequence: transaction.signerData.sequence,\n      },\n    ],\n    transaction.fee.amount,\n    gasLimit,\n    undefined,\n    undefined,\n    // 1,\n  );\n\n  return authInfoBytes;\n};\n\nexport const getCosmosTx = async (mnemonic: string): Promise<RawTransaction> => {\n  /* 1. get Account */\n  const wallet = await DirectSecp256k1HdWallet.fromMnemonic(mnemonic);\n  const [{ address, pubkey }] = await wallet.getAccounts();\n\n  /* 2. make raw transaction */\n  const rpcUrl = 'https://cosmos-testnet-rpc.allthatnode.com:26657';\n  const client = await StargateClient.connect(rpcUrl);\n  const sequence = await client.getSequence(address);\n  const chainId = await client.getChainId();\n\n  const transaction = {\n    signerData: {\n      accountNumber: sequence.accountNumber,\n      sequence: sequence.sequence,\n      chainId,\n    },\n    fee: {\n      amount: [\n        {\n          denom: 'uatom',\n          amount: '10000',\n        },\n      ],\n      gas: '180000', // 180k\n    },\n    memo: 'dsrv/kms',\n    msgs: [\n      {\n        typeUrl: '/cosmos.bank.v1beta1.MsgSend',\n        value: {\n          fromAddress: address,\n          toAddress: 'cosmos12xt4x49p96n9aw4umjwyp3huct27nwr2g4r6p2', // allthatnode\n          amount: [{ denom: 'uatom', amount: '10000' }],\n        },\n      },\n    ],\n    sequence: sequence.sequence,\n  };\n\n  /* create signDoc */\n  const txBodyBytes = getTxBodyBytes(transaction);\n  const authInfoBytes = getAuthInfoBytes(transaction, pubkey);\n\n  const signDoc = makeSignDoc(\n    txBodyBytes,\n    authInfoBytes,\n    transaction.signerData.chainId,\n    Number(transaction.signerData.accountNumber),\n  );\n\n  /* serialized singDoc */\n\n  const uint8SignDoc = makeSignBytes(signDoc);\n  const serializedTx = `0x${Buffer.from(uint8SignDoc).toString('hex')}`;\n\n  return {\n    unSignedTx: signDoc,\n    serializedTx,\n  };\n};\n")),(0,a.kt)("h3",{id:"2-getcosmossignature"},"2. getCosmosSignature"),(0,a.kt)("p",null,"We then develop a method called ",(0,a.kt)("inlineCode",{parentName:"p"},"getCosmosSignature")," that produces a signature by using serializedTx as a factor in order to gain a signature for the transaction."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="getCosmosSignature.ts"',title:'"getCosmosSignature.ts"'},"import { CHAIN } from '@dsrv/kms/lib/types';\nimport { Cosmos } from '@dsrv/kms/lib/blockchains/cosmos';\n\nexport const getCosmosSignature = (serializedTx: string): string => {\n  const { signature } = Cosmos.signTx(\n    {\n      mnemonic,\n      path: { type: CHAIN.COSMOS, account: 0, index: 0 },\n    },\n    serializedTx,\n  );\n\n  return signature;\n};\n")),(0,a.kt)("h3",{id:"3-createcosmossignedtx"},"3. createCosmosSignedTx"),(0,a.kt)("p",null,"Finally, we develop the ",(0,a.kt)("inlineCode",{parentName:"p"},"createCosmosSignedTx")," function, which takes an ",(0,a.kt)("inlineCode",{parentName:"p"},"unsignedTx")," and a ",(0,a.kt)("inlineCode",{parentName:"p"},"signature")," generated earlier and returns a signed transaction."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="createCosmosSignedTx.ts"',title:'"createCosmosSignedTx.ts"'},"import { TxRaw, SignDoc } from 'cosmjs-types/cosmos/tx/v1beta1/tx';\n\ninterface createCosmosSignedTxProps {\n  unSignedTx: SignDoc;\n  signature: string;\n}\n\n/* create singedTx by combining tx and signature */\nexport const createCosmosSignedTx = ({\n  unSignedTx,\n  signature,\n}: createCosmosSignedTxProps): string => {\n  const txRaw = TxRaw.fromPartial({\n    bodyBytes: unSignedTx.bodyBytes,\n    authInfoBytes: unSignedTx.authInfoBytes,\n    signatures: [new Uint8Array(Buffer.from(signature.replace('0x', ''), 'hex'))],\n  });\n\n  const txByte = TxRaw.encode(txRaw).finish();\n  const signedTx = `0x${Buffer.from(txByte).toString('hex')}`;\n\n  return signedTx;\n};\n")),(0,a.kt)("p",null,"Finally, you can construct a ",(0,a.kt)("inlineCode",{parentName:"p"},"getCosmosSignedTx")," function that returns a signed transaction by combining the functions you made before, ",(0,a.kt)("inlineCode",{parentName:"p"},"getCosmosTx"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"getCosmosSignature"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"createCosmosSignedTx"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="getCosmosSignedTx.ts"',title:'"getCosmosSignedTx.ts"'},"export const getCosmosSignedTx = async (mnemonic: string) => {\n  /* 1. get rawTransaction */\n  const { serializedTx, unSignedTx } = await getCosmosTx(mnemonic);\n  /* 2. get signature */\n  const cosmosSignature = getCosmosSignature(serializedTx);\n  /* 3. create singedTx by combining rawTransaction and signature */\n  const cosmosSignedTx = createCosmosSignedTx({\n    unSignedTx,\n    signature: cosmosSignature,\n  });\n\n  return cosmosSignedTx;\n};\n")),(0,a.kt)("h2",{id:"send-signed-transaction"},"Send Signed transaction"),(0,a.kt)("p",null,"You can transmit the transaction using a signed transaction you've prepared."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="sendCosmosTransaction.ts"',title:'"sendCosmosTransaction.ts"'},"import { StargateClient, DeliverTxResponse } from '@cosmjs/stargate';\n\nexport const sendCosmosTransaction = async (serializedTx: string): Promise<DeliverTxResponse> => {\n  const rpcUrl = 'https://cosmos-testnet-rpc.allthatnode.com:26657';\n  const client = await StargateClient.connect(rpcUrl);\n  const txResult = await client.broadcastTx(\n    Uint8Array.from(Buffer.from(serializedTx.replace('0x', ''), 'hex')),\n  );\n  return txResult;\n};\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="main.ts"',title:'"main.ts"'},"const mnemonic = 'sample mnemonic';\nconst main = async () => {\n  const cosmosSignedTx = await getCosmosSignedTx(mnemonic);\n  const cosmosTxResult = await sendCosmosTransaction(cosmosSignedTx);\n  console.log('Cosmos Tx Result : ', cosmosTxResult);\n};\nmain();\n")),(0,a.kt)("h2",{id:"examples"},"Examples"),(0,a.kt)("p",null,"You can send the transaction directly using the example below. The transaction needs to be sent through the faucet. Through the ",(0,a.kt)("a",{parentName:"p",href:"https://www.allthatnode.com/faucet/cosmos.dsrv"},"following URL"),", you can access the Cosmos testnet faucet."),(0,a.kt)("admonition",{type:"warning"},(0,a.kt)("p",{parentName:"admonition"},"The loss of all cryptocurrency holdings is possible if mnemonic is revealed. To execute the following example, use a test or development mnemonic.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function sendTransaction() {\n  const [mnemonic, setMnemonic] = React.useState('');\n  const [account, setAccount] = React.useState(null);\n  const [signature, setSignature] = React.useState(null);\n  const [signedTx, setSignedTx] = React.useState(null);\n  const [txResult, setTxResult] = React.useState(null);\n\n  const getTxBodyBytes = (transaction) => {\n    const registry = new Registry(defaultRegistryTypes);\n\n    const txBodyEncodeObject = {\n      typeUrl: '/cosmos.tx.v1beta1.TxBody',\n      value: {\n        messages: transaction.msgs,\n        memo: transaction.memo,\n      },\n    };\n\n    const txBodyBytes = registry.encode(txBodyEncodeObject);\n    return txBodyBytes;\n  };\n\n  const getAuthInfoBytes = (transaction, pubkey) => {\n    const gasLimit = Int53.fromString(transaction.fee.gas).toNumber();\n    const authInfoBytes = makeAuthInfoBytes(\n      [\n        {\n          pubkey: encodePubkey(encodeSecp256k1Pubkey(pubkey)),\n          sequence: transaction.signerData.sequence,\n        },\n      ],\n      transaction.fee.amount,\n      gasLimit,\n      undefined,\n      undefined,\n      // 1,\n    );\n\n    return authInfoBytes;\n  };\n\n  const getCosmosTx = async () => {\n    try {\n      /* 1. get Account */\n      const wallet = await DirectSecp256k1HdWallet.fromMnemonic(mnemonic);\n      const [{ address, pubkey }] = await wallet.getAccounts();\n      setAccount(address);\n\n      /* 2. make raw transaction */\n      const rpcUrl = 'https://cosmos-testnet-rpc.allthatnode.com:26657';\n      const client = await StargateClient.connect(rpcUrl);\n      const sequence = await client.getSequence(address);\n      const chainId = await client.getChainId();\n\n      const transaction = {\n        signerData: {\n          accountNumber: sequence.accountNumber,\n          sequence: sequence.sequence,\n          chainId,\n        },\n        fee: {\n          amount: [\n            {\n              denom: 'uatom',\n              amount: '10000',\n            },\n          ],\n          gas: '180000', // 180k\n        },\n        memo: 'dsrv/kms',\n        msgs: [\n          {\n            typeUrl: '/cosmos.bank.v1beta1.MsgSend',\n            value: {\n              fromAddress: address,\n              toAddress: 'cosmos12xt4x49p96n9aw4umjwyp3huct27nwr2g4r6p2', // allthatnode\n              amount: [{ denom: 'uatom', amount: '10000' }],\n            },\n          },\n        ],\n        sequence: sequence.sequence,\n      };\n\n      /* 3. create signDoc */\n      const txBodyBytes = getTxBodyBytes(transaction);\n      const authInfoBytes = getAuthInfoBytes(transaction, pubkey);\n\n      const signDoc = makeSignDoc(\n        txBodyBytes,\n        authInfoBytes,\n        transaction.signerData.chainId,\n        Number(transaction.signerData.accountNumber),\n      );\n      /* 4. serialized singDoc */\n\n      const uint8SignDoc = makeSignBytes(signDoc);\n      const serializedTx = `0x${Buffer.from(uint8SignDoc).toString('hex')}`;\n\n      return {\n        unSignedTx: signDoc,\n        serializedTx,\n      };\n    } catch (e) {\n      alert(`error : ${e.message}`);\n    }\n  };\n  const getCosmosSignature = (serializedTx) => {\n    try {\n      const { signature } = Cosmos.signTx(\n        {\n          mnemonic,\n          path: { type: CHAIN.COSMOS, account: 0, index: 0 },\n        },\n        serializedTx,\n      );\n\n      setSignature(signature);\n      return signature;\n    } catch (e) {\n      alert(`error : ${e.message}`);\n    }\n  };\n\n  const createCosmosSignedTx = ({ unSignedTx, signature }) => {\n    try {\n      const txRaw = TxRaw.fromPartial({\n        bodyBytes: unSignedTx.bodyBytes,\n        authInfoBytes: unSignedTx.authInfoBytes,\n        signatures: [new Uint8Array(Buffer.from(signature.replace('0x', ''), 'hex'))],\n      });\n\n      const txByte = TxRaw.encode(txRaw).finish();\n      const signedTx = `0x${Buffer.from(txByte).toString('hex')}`;\n\n      return signedTx;\n    } catch (e) {\n      alert(`error : ${e.message}`);\n    }\n  };\n  const getCosmosSignedTx = async () => {\n    try {\n      /* 1. get rawTransaction */\n      const { serializedTx, unSignedTx } = await getCosmosTx();\n      /* 2. get signature */\n      const cosmosSignature = getCosmosSignature(serializedTx);\n      /* 3. create singedTx by combining rawTransaction and signature */\n      const cosmosSignedTx = createCosmosSignedTx({\n        unSignedTx,\n        signature: cosmosSignature,\n      });\n      setSignedTx(cosmosSignedTx);\n      return cosmosSignedTx;\n    } catch (e) {\n      alert(`error : ${e.message}`);\n    }\n  };\n  const sendCosmosTransaction = async (cosmosSignedTx) => {\n    try {\n      const rpcUrl = 'https://cosmos-testnet-rpc.allthatnode.com:26657';\n      const client = await StargateClient.connect(rpcUrl);\n      const result = await client.broadcastTx(\n        Uint8Array.from(Buffer.from(cosmosSignedTx.replace('0x', ''), 'hex')),\n      );\n      return result;\n    } catch (e) {\n      alert(`error : ${e.message}`);\n    }\n  };\n\n  const handleClick = async () => {\n    account && setAccount(null);\n    signature && setSignature(null);\n    signedTx && setSignedTx(null);\n    txResult && setTxResult(null);\n    const cosmosSignedTx = await getCosmosSignedTx();\n    const cosmosTxResult = await sendCosmosTransaction(cosmosSignedTx);\n    setTxResult(cosmosTxResult);\n  };\n\n  const handleChange = (e) => {\n    setMnemonic(e.target.value);\n\n    account && setAccount(null);\n    signature && setSignature(null);\n    signedTx && setSignedTx(null);\n    txResult && setTxResult(null);\n  };\n\n  return (\n    <>\n      <Input\n        value={mnemonic}\n        onChange={handleChange}\n        placeholder=\"Your test mnemonic\"\n        style={{ marginRight: '8px' }}\n      />\n      <Button onClick={handleClick} type=\"button\">\n        send transaction\n      </Button>\n      {account && (\n        <ResultTooltip style={{ background: '#F08080' }}>\n          <b>Account:</b> {account}\n        </ResultTooltip>\n      )}\n      {signature && (\n        <ResultTooltip style={{ background: '#F4F4F4', color: 'black' }}>\n          <b>Signature:</b> {signature}\n        </ResultTooltip>\n      )}\n      {signedTx && (\n        <ResultTooltip style={{ background: '#3B48DF' }}>\n          <b>Signed Transaction:</b> {signedTx}\n        </ResultTooltip>\n      )}\n      {txResult && (\n        <ResultTooltip style={{ background: '#FFD400', color: 'black' }}>\n          <b>Transaction Hash:</b> {txResult.transactionHash}\n        </ResultTooltip>\n      )}\n    </>\n  );\n}\n")))}d.isMDXComponent=!0}}]);