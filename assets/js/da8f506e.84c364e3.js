"use strict";(self.webpackChunkwelldone_docs=self.webpackChunkwelldone_docs||[]).push([[1814],{3905:function(n,t,e){e.d(t,{Zo:function(){return l},kt:function(){return g}});var a=e(67294);function s(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function r(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,a)}return e}function o(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?r(Object(e),!0).forEach((function(t){s(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function i(n,t){if(null==n)return{};var e,a,s=function(n,t){if(null==n)return{};var e,a,s={},r=Object.keys(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||(s[e]=n[e]);return s}(n,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(s[e]=n[e])}return s}var c=a.createContext({}),u=function(n){var t=a.useContext(c),e=t;return n&&(e="function"==typeof n?n(t):o(o({},t),n)),e},l=function(n){var t=u(n.components);return a.createElement(c.Provider,{value:t},n.children)},p={inlineCode:"code",wrapper:function(n){var t=n.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(n,t){var e=n.components,s=n.mdxType,r=n.originalType,c=n.parentName,l=i(n,["components","mdxType","originalType","parentName"]),d=u(e),g=s,m=d["".concat(c,".").concat(g)]||d[g]||p[g]||r;return e?a.createElement(m,o(o({ref:t},l),{},{components:e})):a.createElement(m,o({ref:t},l))}));function g(n,t){var e=arguments,s=t&&t.mdxType;if("string"==typeof n||s){var r=e.length,o=new Array(r);o[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=n,i.mdxType="string"==typeof n?n:s,o[1]=i;for(var u=2;u<r;u++)o[u]=e[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,e)}d.displayName="MDXCreateElement"},17583:function(n,t,e){e.r(t),e.d(t,{assets:function(){return l},contentTitle:function(){return c},default:function(){return g},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return p}});var a=e(83117),s=e(80102),r=(e(67294),e(3905)),o=["components"],i={keywords:["aptos sendTransaction","dapp:sendTransaction","aptos","kms","@dsrv/kms"],description:"Sending Transactions using @dsrv/kms in Aptos"},c="Aptos",u={unversionedId:"tutorials/kms/aptos",id:"tutorials/kms/aptos",title:"Aptos",description:"Sending Transactions using @dsrv/kms in Aptos",source:"@site/docs/tutorials/kms/aptos.md",sourceDirName:"tutorials/kms",slug:"/tutorials/kms/aptos",permalink:"/tutorials/kms/aptos",draft:!1,editUrl:"https://github.com/welldonestudio/welldonestudio.github.io/tree/master/docs/tutorials/kms/aptos.md",tags:[],version:"current",frontMatter:{keywords:["aptos sendTransaction","dapp:sendTransaction","aptos","kms","@dsrv/kms"],description:"Sending Transactions using @dsrv/kms in Aptos"},sidebar:"tutorialSidebar",previous:{title:"KMS",permalink:"/tutorials/kms/"},next:{title:"Celo",permalink:"/tutorials/kms/celo"}},l={},p=[{value:"Create Signed transaction",id:"create-signed-transaction",level:2},{value:"1. getAptosTx",id:"1-getaptostx",level:3},{value:"2. getAptosSignature",id:"2-getaptossignature",level:3},{value:"3. createAptosSignedTx",id:"3-createaptossignedtx",level:3},{value:"Send Signed transaction",id:"send-signed-transaction",level:2},{value:"Examples",id:"examples",level:2}],d={toc:p};function g(n){var t=n.components,e=(0,s.Z)(n,o);return(0,r.kt)("wrapper",(0,a.Z)({},d,e,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"aptos"},"Aptos"),(0,r.kt)("div",null,(0,r.kt)("span",{className:"author-sm"},"November 11, 2022"),(0,r.kt)("div",{className:"author-div"},(0,r.kt)("div",{className:"author-avatars"},(0,r.kt)("a",{href:"https://github.com/Nahee-Park",target:"_blank"},(0,r.kt)("img",{src:"https://avatars.githubusercontent.com/u/81923229?v=4"}))),(0,r.kt)("div",null,(0,r.kt)("span",{className:"author-name"},"Nahee Park"),(0,r.kt)("br",null),(0,r.kt)("span",{className:"author-sm"},"Software Engineer, DSRV ")))),(0,r.kt)("br",null),(0,r.kt)("admonition",{title:"Prerequisites",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The Aptos part carries out the practice using ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/aptos"},"aptos"),". Please prepare by installing the package.")),(0,r.kt)("h2",{id:"create-signed-transaction"},"Create Signed transaction"),(0,r.kt)("p",null,"For a signed transaction, there are three essential steps."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Create a raw transaction first."),(0,r.kt)("li",{parentName:"ol"},"Make a raw transaction signature."),(0,r.kt)("li",{parentName:"ol"},"Convert a raw transaction into a signed transaction by adding a signature.")),(0,r.kt)("h3",{id:"1-getaptostx"},"1. getAptosTx"),(0,r.kt)("p",null,"Transaction and signature are needed. We first develop a ",(0,r.kt)("inlineCode",{parentName:"p"},"getAptosTx")," function to generate raw transaction because it is necessary to have a raw transaction to receive a signature via kms."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="getAptosTx.ts"',title:'"getAptosTx.ts"'},"import { AptosClient, TxnBuilderTypes, BCS } from 'aptos';\nimport { Account, CHAIN } from '@dsrv/kms/lib/types';\nimport { Aptos } from '@dsrv/kms/lib/blockchains/aptos';\nimport { sha3_256 } from 'js-sha3';\n\ninterface RawTransaction {\n  unSignedTx: TxnBuilderTypes.RawTransaction;\n  serializedTx: string;\n}\nconst aptos = new AptosClient('https://fullnode.devnet.aptoslabs.com/v1');\n\nconst getAccountExists = async (address: string) => {\n  try {\n    await aptos.getAccountResources(address);\n  } catch (error) {\n    const chainId = await aptos.getChainId();\n    const url = `https://faucet.${\n      chainId === 2 ? 'testnet' : 'devnet'\n    }.aptoslabs.com/mint?amount=0&address=${address.replace('0x', '')}`;\n    // eslint-disable-next-line no-undef\n    await fetch(url, { method: 'POST' });\n    await aptos.getAccountResources(address);\n  }\n};\n\nexport const getAptosTx = async (mnemonic: string) => {\n  const MAX_GAS_AMOUNT = 150;\n  const GAS_UNIT_PRICE = 100;\n  const amount = 100;\n\n  /* 1. get Account */\n  const account = Aptos.getAccount({\n    mnemonic,\n    path: { type: CHAIN.APTOS, account: 0, index: 0 },\n  });\n\n  await getAccountExists(account.address);\n  const { sequence_number: sequenceNumber } = await aptos.getAccount(account.address);\n\n  /* 2. make raw transaction */\n  const chainId = await aptos.getChainId();\n  const expirationTimestampSecs = Math.floor(Date.now() / 1000) + 300;\n\n  const token = new TxnBuilderTypes.TypeTagStruct(\n    TxnBuilderTypes.StructTag.fromString('0x1::aptos_coin::AptosCoin'),\n  );\n\n  const entryFunctionPayload = new TxnBuilderTypes.TransactionPayloadEntryFunction(\n    TxnBuilderTypes.EntryFunction.natural(\n      '0x1::coin',\n      'transfer',\n      [token],\n      [\n        BCS.bcsToBytes(TxnBuilderTypes.AccountAddress.fromHex(account.address)),\n        BCS.bcsSerializeUint64(amount),\n      ],\n    ),\n  );\n\n  const rawTxn = new TxnBuilderTypes.RawTransaction(\n    TxnBuilderTypes.AccountAddress.fromHex(account.address),\n    BigInt(sequenceNumber),\n    entryFunctionPayload,\n    BigInt(MAX_GAS_AMOUNT),\n    BigInt(GAS_UNIT_PRICE),\n    BigInt(expirationTimestampSecs),\n    new TxnBuilderTypes.ChainId(chainId),\n  );\n\n  const rawTxnWithSalt = `0x${Buffer.concat([\n    Buffer.from(sha3_256(Buffer.from('APTOS::RawTransaction', 'ascii')), 'hex'),\n    Buffer.from(BCS.bcsToBytes(rawTxn)),\n  ]).toString('hex')}`;\n\n  return {\n    serializedTx: rawTxnWithSalt,\n    unSignedTx: rawTxn,\n  };\n};\n")),(0,r.kt)("h3",{id:"2-getaptossignature"},"2. getAptosSignature"),(0,r.kt)("p",null,"We then develop a method called ",(0,r.kt)("inlineCode",{parentName:"p"},"getAptosSignature")," that produces a signature by using serializedTx as a factor in order to gain a signature for the transaction."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="getAptosSignature.ts"',title:'"getAptosSignature.ts"'},"import { CHAIN } from '@dsrv/kms/lib/types';\nimport { Aptos } from '@dsrv/kms/lib/blockchains/aptos';\n\nexport const getAptosSignature = (serializedTx: string): string => {\n  const { signature } = Aptos.signTx(\n    {\n      mnemonic,\n      path: { type: CHAIN.APTOS, account: 0, index: 0 },\n    },\n    serializedTx,\n  );\n\n  return signature;\n};\n")),(0,r.kt)("h3",{id:"3-createaptossignedtx"},"3. createAptosSignedTx"),(0,r.kt)("p",null,"Finally, we develop the ",(0,r.kt)("inlineCode",{parentName:"p"},"createAptosSignedTx")," function, which takes an ",(0,r.kt)("inlineCode",{parentName:"p"},"serializedTx"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"unsignedTx")," and a ",(0,r.kt)("inlineCode",{parentName:"p"},"signature")," generated earlier and returns a signed transaction."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="createAptosSignedTx.ts"',title:'"createAptosSignedTx.ts"'},"import { TxnBuilderTypes, BCS } from 'aptos';\nimport { Aptos } from '@dsrv/kms/lib/blockchains/aptos';\nimport { CHAIN } from '@dsrv/kms/lib/types';\n\ninterface createAptosSignedTxProps {\n  serializedTx: string;\n  signature: string;\n  mnemonic: string;\n}\n\n/* create singedTx by combining tx and signature */\nexport const createAptosSignedTx = ({\n  serializedTx,\n  signature,\n  mnemonic,\n}: createAptosSignedTxProps): string => {\n  const account = Aptos.getAccount({\n    mnemonic,\n    path: { type: CHAIN.APTOS, account: 0, index: 0 },\n  });\n  const rawTxn = TxnBuilderTypes.RawTransaction.deserialize(\n    new BCS.Deserializer(Buffer.from(serializedTx.replace('0x', '').slice(64), 'hex')),\n  );\n\n  const signed = new TxnBuilderTypes.SignedTransaction(\n    rawTxn,\n    new TxnBuilderTypes.TransactionAuthenticatorEd25519(\n      new TxnBuilderTypes.Ed25519PublicKey(Buffer.from(account.publicKey.replace('0x', ''), 'hex')),\n      new TxnBuilderTypes.Ed25519Signature(Buffer.from(signature.replace('0x', ''), 'hex')),\n    ),\n  );\n\n  return signed;\n};\n")),(0,r.kt)("p",null,"Finally, you can construct a ",(0,r.kt)("inlineCode",{parentName:"p"},"getAptosSignedTx")," function that returns a signed transaction by combining the functions you made before, ",(0,r.kt)("inlineCode",{parentName:"p"},"getAptosTx"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"getAptosSignature"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"createAptosSignedTx"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="getAptosSignedTx.ts"',title:'"getAptosSignedTx.ts"'},"export const getAptosSignedTx = async (mnemonic: string) => {\n  /* 1. get rawTransaction */\n  const { serializedTx, unSignedTx } = await getAptosTx(mnemonic);\n  /* 2. get signature */\n  const aptosSignature = getAptosSignature(serializedTx);\n  /* 3. create singedTx by combining rawTransaction and signature */\n  const aptosSignedTx = createAptosSignedTx({\n    unSignedTx,\n    signature: aptosSignature,\n    mnemonic,\n  });\n\n  return aptosSignedTx;\n};\n")),(0,r.kt)("h2",{id:"send-signed-transaction"},"Send Signed transaction"),(0,r.kt)("p",null,"You can transmit the transaction using a signed transaction you've prepared."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="sendAptosTransaction.ts"',title:'"sendAptosTransaction.ts"'},"import { TxnBuilderTypes, BCS } from 'aptos';\n\nexport const sendAptosTransaction = async (signedTx: TxnBuilderTypes.SignedTransaction) => {\n  const rpcUrl = 'https://fullnode.devnet.aptoslabs.com/v1';\n\n  const resp = await fetch(`${rpcUrl}/transactions`, {\n    method: 'POST',\n    headers: {\n      // https://github.com/aptos-labs/aptos-core/blob/e7d5f952afe3afcf5d1415b67e167df6d49019bf/ecosystem/typescript/sdk/src/aptos_client.ts#L327\n      'Content-Type': 'application/x.aptos.signed_transaction+bcs',\n    },\n    body: BCS.bcsToBytes(signedTx),\n  });\n\n  const result = await resp.json();\n\n  return result;\n};\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="main.ts"',title:'"main.ts"'},"const mnemonic = 'sample mnemonic';\nconst main = async () => {\n  const aptosSignedTx = await getAptosSignedTx(mnemonic);\n  const aptosTxResult = await sendAptosTransaction(aptosSignedTx);\n  console.log('Aptos Tx Result : ', aptosTxResult);\n};\nmain();\n")),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("p",null,"To complete the transaction, follow the steps outlined below. A faucet is required to transmit a transaction. You can request faucet through the FAUCET tab in the wallet."),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"The loss of all cryptocurrency holdings is possible if mnemonic is revealed. To execute the following example, use a test or development mnemonic.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function sendTransaction() {\n  const [mnemonic, setMnemonic] = React.useState('');\n  const [account, setAccount] = React.useState(null);\n  const [signature, setSignature] = React.useState(null);\n  const [txResult, setTxResult] = React.useState(null);\n\n  const aptos = new AptosClient('https://fullnode.devnet.aptoslabs.com/v1');\n\n  const getAccountExists = async (address) => {\n    try {\n      await aptos.getAccountResources(address);\n    } catch (error) {\n      const chainId = await aptos.getChainId();\n      const url = `https://faucet.${\n        chainId === 2 ? 'testnet' : 'devnet'\n      }.aptoslabs.com/mint?amount=0&address=${address.replace('0x', '')}`;\n      // eslint-disable-next-line no-undef\n      await fetch(url, { method: 'POST' });\n      await aptos.getAccountResources(address);\n    }\n  };\n\n  const getAptosTx = async () => {\n    try {\n      const MAX_GAS_AMOUNT = 150;\n      const GAS_UNIT_PRICE = 100;\n      const amount = 100;\n\n      /* 1. get Account */\n      const account = Aptos.getAccount({\n        mnemonic,\n        path: { type: CHAIN.APTOS, account: 0, index: 0 },\n      });\n      setAccount(account.address);\n      await getAccountExists(account.address);\n      const { sequence_number: sequenceNumber } = await aptos.getAccount(account.address);\n\n      /* 2. make raw transaction */\n      const chainId = await aptos.getChainId();\n      const expirationTimestampSecs = Math.floor(Date.now() / 1000) + 300;\n\n      const token = new TxnBuilderTypes.TypeTagStruct(\n        TxnBuilderTypes.StructTag.fromString('0x1::aptos_coin::AptosCoin'),\n      );\n\n      const entryFunctionPayload = new TxnBuilderTypes.TransactionPayloadEntryFunction(\n        TxnBuilderTypes.EntryFunction.natural(\n          '0x1::coin',\n          'transfer',\n          [token],\n          [\n            BCS.bcsToBytes(TxnBuilderTypes.AccountAddress.fromHex(account.address)),\n            BCS.bcsSerializeUint64(amount),\n          ],\n        ),\n      );\n\n      const rawTxn = new TxnBuilderTypes.RawTransaction(\n        TxnBuilderTypes.AccountAddress.fromHex(account.address),\n        BigInt(sequenceNumber),\n        entryFunctionPayload,\n        BigInt(MAX_GAS_AMOUNT),\n        BigInt(GAS_UNIT_PRICE),\n        BigInt(expirationTimestampSecs),\n        new TxnBuilderTypes.ChainId(chainId),\n      );\n\n      const rawTxnWithSalt = `0x${Buffer.concat([\n        Buffer.from(sha3_256(Buffer.from('APTOS::RawTransaction', 'ascii')), 'hex'),\n        Buffer.from(BCS.bcsToBytes(rawTxn)),\n      ]).toString('hex')}`;\n\n      return {\n        serializedTx: rawTxnWithSalt,\n        unSignedTx: rawTxn,\n      };\n    } catch (e) {\n      alert(`error : ${e.message}`);\n    }\n  };\n  const getAptosSignature = (serializedTx) => {\n    try {\n      const { signature } = Aptos.signTx(\n        {\n          mnemonic,\n          path: { type: CHAIN.APTOS, account: 0, index: 0 },\n        },\n        serializedTx,\n      );\n      setSignature(signature);\n      return signature;\n    } catch (e) {\n      alert(`error : ${e.message}`);\n    }\n  };\n  const createAptosSignedTx = ({ serializedTx, signature }) => {\n    try {\n      const account = Aptos.getAccount({\n        mnemonic,\n        path: { type: CHAIN.APTOS, account: 0, index: 0 },\n      });\n      const rawTxn = TxnBuilderTypes.RawTransaction.deserialize(\n        new BCS.Deserializer(Buffer.from(serializedTx.replace('0x', '').slice(64), 'hex')),\n      );\n\n      const signed = new TxnBuilderTypes.SignedTransaction(\n        rawTxn,\n        new TxnBuilderTypes.TransactionAuthenticatorEd25519(\n          new TxnBuilderTypes.Ed25519PublicKey(\n            Buffer.from(account.publicKey.replace('0x', ''), 'hex'),\n          ),\n          new TxnBuilderTypes.Ed25519Signature(Buffer.from(signature.replace('0x', ''), 'hex')),\n        ),\n      );\n\n      return signed;\n    } catch (e) {\n      alert(`error : ${e.message}`);\n    }\n  };\n  const getAptosSignedTx = async () => {\n    try {\n      /* 1. get rawTransaction */\n      const { serializedTx, unSignedTx } = await getAptosTx();\n      /* 2. get signature */\n      const aptosSignature = getAptosSignature(serializedTx);\n      /* 3. create singedTx by combining rawTransaction and signature */\n      const aptosSignedTx = createAptosSignedTx({\n        serializedTx,\n        signature: aptosSignature,\n      });\n      return aptosSignedTx;\n    } catch (e) {\n      alert(`error : ${e.message}`);\n    }\n  };\n  const sendAptosTransaction = async (aptosSignedTx) => {\n    try {\n      const rpcUrl = 'https://fullnode.devnet.aptoslabs.com/v1';\n\n      const resp = await fetch(`${rpcUrl}/transactions`, {\n        method: 'POST',\n        headers: {\n          // https://github.com/aptos-labs/aptos-core/blob/e7d5f952afe3afcf5d1415b67e167df6d49019bf/ecosystem/typescript/sdk/src/aptos_client.ts#L327\n          'Content-Type': 'application/x.aptos.signed_transaction+bcs',\n        },\n        body: BCS.bcsToBytes(aptosSignedTx),\n      });\n\n      const result = await resp.json();\n\n      return result;\n    } catch (e) {\n      alert(`error : ${e.message}`);\n    }\n  };\n\n  const handleClick = async () => {\n    account && setAccount(null);\n    signature && setSignature(null);\n    txResult && setTxResult(null);\n    const aptosSignedTx = await getAptosSignedTx();\n    const aptosTxResult = await sendAptosTransaction(aptosSignedTx);\n\n    setTxResult(aptosTxResult);\n  };\n\n  const handleChange = (e) => {\n    setMnemonic(e.target.value);\n\n    account && setAccount(null);\n    signature && setSignature(null);\n    txResult && setTxResult(null);\n  };\n\n  return (\n    <>\n      <Input\n        value={mnemonic}\n        onChange={handleChange}\n        placeholder=\"Your test mnemonic\"\n        style={{ marginRight: '8px' }}\n      />\n      <Button onClick={handleClick} type=\"button\">\n        send transaction\n      </Button>\n      {account && (\n        <ResultTooltip style={{ background: '#F08080' }}>\n          <b>Account:</b> {account}\n        </ResultTooltip>\n      )}\n      {signature && (\n        <ResultTooltip style={{ background: '#F4F4F4', color: 'black' }}>\n          <b>Signature:</b> {signature}\n        </ResultTooltip>\n      )}\n      {txResult && (\n        <ResultTooltip style={{ background: '#FFD400', color: 'black' }}>\n          <b>Transaction Hash:</b> {txResult.hash}\n        </ResultTooltip>\n      )}\n    </>\n  );\n}\n")))}g.isMDXComponent=!0}}]);